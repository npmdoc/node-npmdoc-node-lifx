<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/MariusRumpf/node-lifx#readme"

    >node-lifx (v0.8.0)</a>
</h1>
<h4>Node.js implementation of the LIFX protocol</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-lifx">module node-lifx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client">
            function <span class="apidocSignatureSpan">node-lifx.</span>Client
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_">
            function <span class="apidocSignatureSpan">node-lifx.</span>Client.super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light">
            function <span class="apidocSignatureSpan">node-lifx.</span>Light
            <span class="apidocSignatureSpan">(constr)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-lifx.</span>Client.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-lifx.</span>Client.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-lifx.</span>Light.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-lifx.</span>constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-lifx.</span>packet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-lifx.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-lifx.Client">module node-lifx.Client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.Client">
            function <span class="apidocSignatureSpan">node-lifx.</span>Client
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_">
            function <span class="apidocSignatureSpan">node-lifx.Client.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-lifx.Client.prototype">module node-lifx.Client.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.addMessageHandler">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>addMessageHandler
            <span class="apidocSignatureSpan">(type, callback, sequenceNumber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.address">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>address
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.destroy">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.init">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>init
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.light">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>light
            <span class="apidocSignatureSpan">(identifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.lights">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>lights
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.processDiscoveryPacket">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>processDiscoveryPacket
            <span class="apidocSignatureSpan">(err, msg, rinfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.processLabelPacket">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>processLabelPacket
            <span class="apidocSignatureSpan">(err, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.processMessageHandlers">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>processMessageHandlers
            <span class="apidocSignatureSpan">(msg, rinfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.send">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>send
            <span class="apidocSignatureSpan">(msg, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.sendingProcess">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>sendingProcess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.setDebug">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>setDebug
            <span class="apidocSignatureSpan">(debug)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.startDiscovery">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>startDiscovery
            <span class="apidocSignatureSpan">(lights)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.startSendingProcess">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>startSendingProcess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.stopDiscovery">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>stopDiscovery
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.prototype.stopSendingProcess">
            function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>stopSendingProcess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-lifx.Client.super_">module node-lifx.Client.super_</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">node-lifx.Client.super_.</span>prefixed</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.super_">
            function <span class="apidocSignatureSpan">node-lifx.Client.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.EventEmitter">
            function <span class="apidocSignatureSpan">node-lifx.Client.super_.</span>EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-lifx.Client.super_.prototype">module node-lifx.Client.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.prototype.addListener">
            function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>addListener
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.prototype.emit">
            function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>emit
            <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.prototype.eventNames">
            function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.prototype.listeners">
            function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>listeners
            <span class="apidocSignatureSpan">(event, exists)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.prototype.off">
            function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>off
            <span class="apidocSignatureSpan">(event, fn, context, once)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.prototype.on">
            function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>on
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.prototype.once">
            function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>once
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.prototype.removeListener">
            function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(event, fn, context, once)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Client.super_.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-lifx.Light">module node-lifx.Light</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.Light">
            function <span class="apidocSignatureSpan">node-lifx.</span>Light
            <span class="apidocSignatureSpan">(constr)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-lifx.Light.prototype">module node-lifx.Light.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.color">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>color
            <span class="apidocSignatureSpan">(hue, saturation, brightness, kelvin, duration, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.colorRgb">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>colorRgb
            <span class="apidocSignatureSpan">(red, green, blue, duration, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.colorRgbHex">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>colorRgbHex
            <span class="apidocSignatureSpan">(hexString, duration, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.getAmbientLight">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getAmbientLight
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.getFirmwareInfo">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getFirmwareInfo
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.getFirmwareVersion">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getFirmwareVersion
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.getHardwareVersion">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getHardwareVersion
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.getLabel">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getLabel
            <span class="apidocSignatureSpan">(callback, cache)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.getMaxIR">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getMaxIR
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.getPower">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getPower
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.getState">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getState
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.getWifiInfo">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getWifiInfo
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.getWifiVersion">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getWifiVersion
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.maxIR">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>maxIR
            <span class="apidocSignatureSpan">(brightness, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.off">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>off
            <span class="apidocSignatureSpan">(duration, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.on">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>on
            <span class="apidocSignatureSpan">(duration, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.Light.prototype.setLabel">
            function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>setLabel
            <span class="apidocSignatureSpan">(label, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-lifx.packet">module node-lifx.packet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.packet.create">
            function <span class="apidocSignatureSpan">node-lifx.packet.</span>create
            <span class="apidocSignatureSpan">(type, params, source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.packet.headerToBuffer">
            function <span class="apidocSignatureSpan">node-lifx.packet.</span>headerToBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.packet.headerToObject">
            function <span class="apidocSignatureSpan">node-lifx.packet.</span>headerToObject
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.packet.toBuffer">
            function <span class="apidocSignatureSpan">node-lifx.packet.</span>toBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.packet.toObject">
            function <span class="apidocSignatureSpan">node-lifx.packet.</span>toObject
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-lifx.packet.</span>typeList</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-lifx.utils">module node-lifx.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.utils.getHardwareDetails">
            function <span class="apidocSignatureSpan">node-lifx.utils.</span>getHardwareDetails
            <span class="apidocSignatureSpan">(vendorId, productId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.utils.getHostIPs">
            function <span class="apidocSignatureSpan">node-lifx.utils.</span>getHostIPs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.utils.getRandomHexString">
            function <span class="apidocSignatureSpan">node-lifx.utils.</span>getRandomHexString
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.utils.isIpv4Format">
            function <span class="apidocSignatureSpan">node-lifx.utils.</span>isIpv4Format
            <span class="apidocSignatureSpan">(ip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.utils.maxNumberInArray">
            function <span class="apidocSignatureSpan">node-lifx.utils.</span>maxNumberInArray
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.utils.minNumberInArray">
            function <span class="apidocSignatureSpan">node-lifx.utils.</span>minNumberInArray
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.utils.readUInt64LE">
            function <span class="apidocSignatureSpan">node-lifx.utils.</span>readUInt64LE
            <span class="apidocSignatureSpan">(buffer, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.utils.rgbHexStringToObject">
            function <span class="apidocSignatureSpan">node-lifx.utils.</span>rgbHexStringToObject
            <span class="apidocSignatureSpan">(rgbHexString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.utils.rgbToHsb">
            function <span class="apidocSignatureSpan">node-lifx.utils.</span>rgbToHsb
            <span class="apidocSignatureSpan">(rgbObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-lifx.utils.writeUInt64LE">
            function <span class="apidocSignatureSpan">node-lifx.utils.</span>writeUInt64LE
            <span class="apidocSignatureSpan">(buffer, offset, input)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-lifx" id="apidoc.module.node-lifx">module node-lifx</a></h1>


    <h2>
        <a href="#apidoc.element.node-lifx.Client" id="apidoc.element.node-lifx.Client">
        function <span class="apidocSignatureSpan">node-lifx.</span>Client
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client() {
  EventEmitter.call(this);

  this.debug = false;
  this.socket = dgram.createSocket(&#x27;udp4&#x27;);
  this.isSocketBound = false;
  this.devices = {};
  this.port = null;
  this.messagesQueue = [];
  this.sendTimer = null;
  this.discoveryTimer = null;
  this.discoveryPacketSequence = 0;
  this.messageHandlers = [{
    type: &#x27;stateService&#x27;,
    callback: this.processDiscoveryPacket.bind(this)
  }, {
    type: &#x27;stateLabel&#x27;,
    callback: this.processLabelPacket.bind(this)
  }, {
    type: &#x27;stateLight&#x27;,
    callback: this.processLabelPacket.bind(this)
  }];
  this.sequenceNumber = 0;
  this.lightOfflineTolerance = 3;
  this.messageHandlerTimeout = 45000; // 45 sec
  this.resendPacketDelay = 150;
  this.resendMaxTimes = 5;
  this.source = utils.getRandomHexString(8);
  this.broadcastAddress = &#x27;255.255.255.255&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_" id="apidoc.element.node-lifx.Client.super_">
        function <span class="apidocSignatureSpan">node-lifx.</span>Client.super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light" id="apidoc.element.node-lifx.Light">
        function <span class="apidocSignatureSpan">node-lifx.</span>Light
        <span class="apidocSignatureSpan">(constr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Light(constr) {
  this.client = constr.client;
  this.id = constr.id; // Used to target the light
  this.address = constr.address;
  this.port = constr.port;
  this.label = null;
  this.status = &#x27;on&#x27;;

  this.seenOnDiscovery = constr.seenOnDiscovery;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-lifx.Client" id="apidoc.module.node-lifx.Client">module node-lifx.Client</a></h1>


    <h2>
        <a href="#apidoc.element.node-lifx.Client.Client" id="apidoc.element.node-lifx.Client.Client">
        function <span class="apidocSignatureSpan">node-lifx.</span>Client
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client() {
  EventEmitter.call(this);

  this.debug = false;
  this.socket = dgram.createSocket(&#x27;udp4&#x27;);
  this.isSocketBound = false;
  this.devices = {};
  this.port = null;
  this.messagesQueue = [];
  this.sendTimer = null;
  this.discoveryTimer = null;
  this.discoveryPacketSequence = 0;
  this.messageHandlers = [{
    type: &#x27;stateService&#x27;,
    callback: this.processDiscoveryPacket.bind(this)
  }, {
    type: &#x27;stateLabel&#x27;,
    callback: this.processLabelPacket.bind(this)
  }, {
    type: &#x27;stateLight&#x27;,
    callback: this.processLabelPacket.bind(this)
  }];
  this.sequenceNumber = 0;
  this.lightOfflineTolerance = 3;
  this.messageHandlerTimeout = 45000; // 45 sec
  this.resendPacketDelay = 150;
  this.resendMaxTimes = 5;
  this.source = utils.getRandomHexString(8);
  this.broadcastAddress = &#x27;255.255.255.255&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_" id="apidoc.element.node-lifx.Client.super_">
        function <span class="apidocSignatureSpan">node-lifx.Client.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-lifx.Client.prototype" id="apidoc.module.node-lifx.Client.prototype">module node-lifx.Client.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.addMessageHandler" id="apidoc.element.node-lifx.Client.prototype.addMessageHandler">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>addMessageHandler
        <span class="apidocSignatureSpan">(type, callback, sequenceNumber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addMessageHandler = function (type, callback, sequenceNumber) {
  if (typeof type !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;LIFX Client addMessageHandler expects type parameter to be string&#x27;);
  }
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX Client addMessageHandler expects callback parameter to be a function&#x27;);
  }

  var typeName = _.find(Packet.typeList, {name: type});
  if (typeName === undefined) {
    throw new RangeError(&#x27;LIFX Client addMessageHandler unknown packet type: &#x27; + type);
  }

  var handler = {
    type: type,
    callback: callback.bind(this),
    timestamp: Date.now()
  };

  if (sequenceNumber !== undefined) {
    if (typeof sequenceNumber !== &#x27;number&#x27;) {
      throw new TypeError(&#x27;LIFX Client addMessageHandler expects sequenceNumber to be a integer&#x27;);
    } else {
      handler.sequenceNumber = sequenceNumber;
    }
  }

  this.messageHandlers.push(handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

msg.sequence = this.sequenceNumber;
packet.sequence = this.sequenceNumber;
if (typeof callback === &#x27;function&#x27;) {
  msg.ackRequired = true;
  this.<span class="apidocCodeKeywordSpan">addMessageHandler</span>(&#x27;acknowledgement&#x27;, callback, msg.sequence);
  packet.transactionType = constants.PACKET_TRANSACTION_TYPES.REQUEST_RESPONSE;
}
packet.data = Packet.toBuffer(msg);
this.messagesQueue.unshift(packet);
this.startSendingProcess();

return this.sequenceNumber;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.address" id="apidoc.element.node-lifx.Client.prototype.address">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>address
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">address = function () {
  var address = null;
  try {
    address = this.socket.address();
  } catch (e) {}
  return address;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

client.on(&#x27;light-offline&#x27;, function(light) {
  console.log(&#x27;Light offline. ID:&#x27; + light.id + &#x27;, IP:&#x27; + light.address + &#x27;:&#x27; + light.port);
});

client.on(&#x27;listening&#x27;, function() {
  var address = client.<span class="apidocCodeKeywordSpan">address</span>();
  console.log(
    &#x27;Started LIFX listening on &#x27; +
    address.address + &#x27;:&#x27; + address.port + &#x27;\n&#x27;
  );
});

client.init();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.destroy" id="apidoc.element.node-lifx.Client.prototype.destroy">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  this.stopDiscovery();
  this.stopSendingProcess();
  if (this.isSocketBound) {
    this.socket.close();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x27;use strict&#x27;;

var Lifx = require(&#x27;./lib/lifx&#x27;).Client;
var client = new Lifx();

client.on(&#x27;error&#x27;, function(err) {
console.log(&#x27;LIFX error:\n&#x27; + err.stack);
client.<span class="apidocCodeKeywordSpan">destroy</span>();
});

client.on(&#x27;message&#x27;, function(msg, rinfo) {
if (typeof msg.type === &#x27;string&#x27;) {
  // Known packages send by the lights as broadcast
  switch (msg.type) {
    case &#x27;echoResponse&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.init" id="apidoc.element.node-lifx.Client.prototype.init">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>init
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (options, callback) {
  var defaults = {
    address: &#x27;0.0.0.0&#x27;,
    port: constants.LIFX_DEFAULT_PORT,
    debug: false,
    lightOfflineTolerance: 3,
    messageHandlerTimeout: 45000,
    source: &#x27;&#x27;,
    startDiscovery: true,
    lights: [],
    broadcast: &#x27;255.255.255.255&#x27;,
    resendPacketDelay: 150,
    resendMaxTimes: 3
  };

  options = options || {};
  var opts = _.defaults(options, defaults);

  if (typeof opts.port !== &#x27;number&#x27;) {
    throw new TypeError(&#x27;LIFX Client port option must be a number&#x27;);
  } else if (opts.port &#x3e; 65535 || opts.port &#x3c; 1) {
    throw new RangeError(&#x27;LIFX Client port option must be between 1 and 65535&#x27;);
  }

  if (typeof opts.debug !== &#x27;boolean&#x27;) {
    throw new TypeError(&#x27;LIFX Client debug option must be a boolean&#x27;);
  }
  this.debug = opts.debug;

  if (typeof opts.lightOfflineTolerance !== &#x27;number&#x27;) {
    throw new TypeError(&#x27;LIFX Client lightOfflineTolerance option must be a number&#x27;);
  }
  this.lightOfflineTolerance = opts.lightOfflineTolerance;

  if (typeof opts.messageHandlerTimeout !== &#x27;number&#x27;) {
    throw new TypeError(&#x27;LIFX Client messageHandlerTimeout option must be a number&#x27;);
  }
  this.messageHandlerTimeout = opts.messageHandlerTimeout;

  if (typeof opts.resendPacketDelay !== &#x27;number&#x27;) {
    throw new TypeError(&#x27;LIFX Client resendPacketDelay option must be a number&#x27;);
  }
  this.resendPacketDelay = opts.resendPacketDelay;

  if (typeof opts.resendMaxTimes !== &#x27;number&#x27;) {
    throw new TypeError(&#x27;LIFX Client resendMaxTimes option must be a number&#x27;);
  }
  this.resendMaxTimes = opts.resendMaxTimes;

  if (typeof opts.broadcast !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;LIFX Client broadcast option must be a string&#x27;);
  } else if (!utils.isIpv4Format(opts.broadcast)) {
    throw new TypeError(&#x27;LIFX Client broadcast option does only allow IPv4 address format&#x27;);
  }
  this.broadcastAddress = opts.broadcast;

  if (!_.isArray(opts.lights)) {
    throw new TypeError(&#x27;LIFX Client lights option must be an array&#x27;);
  } else {
    opts.lights.forEach(function(light) {
      if (!utils.isIpv4Format(light)) {
        throw new TypeError(&#x27;LIFX Client lights option array element \&#x27;&#x27; + light + &#x27;\&#x27; is not expected IPv4 format&#x27;);
      }
    });
  }

  if (opts.source !== &#x27;&#x27;) {
    if (typeof opts.source === &#x27;string&#x27;) {
      if (/^[0-9A-F]{8}$/.test(opts.source)) {
        this.source = opts.source;
      } else {
        throw new RangeError(&#x27;LIFX Client source option must be 8 hex chars&#x27;);
      }
    } else {
      throw new TypeError(&#x27;LIFX Client source option must be given as string&#x27;);
    }
  }

  this.socket.on(&#x27;error&#x27;, function(err) {
    this.isSocketBound = false;
    console.error(&#x27;LIFX Client UDP error&#x27;);
    console.trace(err);
    this.socket.close();
    this.emit(&#x27;error&#x27;, err);
  }.bind(this));

  this.socket.on(&#x27;message&#x27;, function(msg, rinfo) {
    // Ignore own messages and false formats
    if (utils.getHostIPs().indexOf(rinfo.address) &#x3e;= 0 || !Buffer.isBuffer(msg)) {
      return;
    }

<span class="apidocCodeCommentSpan">    /* istanbul ignore if  */
</span>    if (this.debug) {
      console.log(&#x27;DEBUG - &#x27; + msg.toString(&#x27;hex&#x27;) + &#x27; from &#x27; + rinfo.address);
    }

    // Parse packet to object
    var parsedMsg = Packet.toObject(msg);

    // Check if packet is read successfully
    if (parsedMsg instanceof Error) {
      console.error(&#x27;LIFX Client invalid packet header error&#x27;);
      console.error(&#x27;Packet: &#x27;, msg.toString(&#x27;hex&#x27;));
      console.trace(parsedMsg);
    } else {
      // Convert type before emitting
      var messageTypeName = _.result(_.find(Packet.typeList, {id: parsedMsg.type}), &#x27;name&#x27;);
      if (messageTypeName !== undefined) {
        parsedMsg.type = messageTypeName;
      }
      // Check for handlers of given message and rinfo
      this.processMessageHandlers(parsedMsg, rinfo);

      this.emit(&#x27;message&#x27;, parsedMsg, rinfo);
    }
  }.bind(this));

  this.socket.bind(opts.port, opts.address, function() {
    this.isSocketBound = true;
    this.socket.setBroadcast(true);
    this.emit(&#x27;listening&#x27;);
    this.port = opts.port;

    // Start scanning
    if (opts.startDiscovery) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var address = client.address();
  console.log(
    &#x27;Started LIFX listening on &#x27; +
    address.address + &#x27;:&#x27; + address.port + &#x27;\n&#x27;
  );
});

client.<span class="apidocCodeKeywordSpan">init</span>();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.light" id="apidoc.element.node-lifx.Client.prototype.light">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>light
        <span class="apidocSignatureSpan">(identifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">light = function (identifier) {
  var result;
  if (typeof identifier !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;LIFX Client light expects identifier for LIFX light to be a string&#x27;);
  }

  // There is no ip or id longer than 45 chars, no label longer than 32 bit
  if (identifier.length &#x3e; 45 &#x26;&#x26; Buffer.byteLength(identifier, &#x27;utf8&#x27;) &#x3e; 32) {
    return false;
  }

  // Dots or colons is high likely an ip
  if (identifier.indexOf(&#x27;.&#x27;) &#x3e;= 0 || identifier.indexOf(&#x27;:&#x27;) &#x3e;= 0) {
    result = _.find(this.devices, {address: identifier}) || false;
    if (result !== false) {
      return result;
    }
  }

  // Search id
  result = _.find(this.devices, {id: identifier}) || false;
  if (result !== false) {
    return result;
  }

  // Search label
  result = _.find(this.devices, {label: identifier}) || false;

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
light.setLabel(&#x27;Kitchen Light 4&#x27;, function(err) {
  if (err) { throw err; }
  console.log(&#x27;New light label has been set&#x27;);
});
```

### Get a light
#### `client.<span class="apidocCodeKeywordSpan">light</span>(identifier)`
Find a light in the list off all lights by ip, label or id.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`identifier` | string | | Light label (case sensitive) `client.light(&#x27;Kitchen&#x27;)`, the ip address `client.light(&#x27;192
.168.2.102&#x27;)` or the light id `client.light(&#x27;0123456789012&#x27;)`

Returns a light object that can then be used to call methods on it. For example `client.light(&#x27;192.168.2.102&#x27;).on()`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.lights" id="apidoc.element.node-lifx.Client.prototype.lights">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>lights
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lights = function (status) {
  if (status === undefined) {
    status = &#x27;on&#x27;;
  } else if (typeof status !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;LIFX Client lights expects status to be a string&#x27;);
  }

  if (status.length &#x3e; 0) {
    if (status !== &#x27;on&#x27; &#x26;&#x26; status !== &#x27;off&#x27;) {
      throw new TypeError(&#x27;Lifx Client lights expects status to be \&#x27;on\&#x27;, \&#x27;off\&#x27; or \&#x27;\&#x27;&#x27;);
    }

    var result = [];
    _.forEach(this.devices, function(light) {
      if (light.status === status) {
        result.push(light);
      }
    });
    return result;
  }

  return this.devices;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
------ | ---- | ------- | -----------
`identifier` | string | | Light label (case sensitive) `client.light(&#x27;Kitchen&#x27;)`, the ip address `client.light(&#x27;192
.168.2.102&#x27;)` or the light id `client.light(&#x27;0123456789012&#x27;)`

Returns a light object that can then be used to call methods on it. For example `client.light(&#x27;192.168.2.102&#x27;).on()`.

### Get all lights

#### `client.<span class="apidocCodeKeywordSpan">lights</span>([filter])`
Get a list of all known lights

Option | Type | Default | Description
------ | ---- | ------- | -----------
`filter` | string | null | Filter list of lights to return only active (`null` or `&#x27;on&#x27;`), inactive (`&#x27;off&#x27;`)
or all (`&#x27;&#x27;`)

### Client events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.processDiscoveryPacket" id="apidoc.element.node-lifx.Client.prototype.processDiscoveryPacket">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>processDiscoveryPacket
        <span class="apidocSignatureSpan">(err, msg, rinfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processDiscoveryPacket = function (err, msg, rinfo) {
  if (err) {
    return;
  }
  if (msg.service === &#x27;udp&#x27; &#x26;&#x26; msg.port === constants.LIFX_DEFAULT_PORT) {
    // Add / update the found gateway
    if (!this.devices[msg.target]) {
      var lightDevice = new Light({
        client: this,
        id: msg.target,
        address: rinfo.address,
        port: msg.port,
        seenOnDiscovery: this.discoveryPacketSequence
      });
      this.devices[msg.target] = lightDevice;

      // Request label
      var labelRequest = Packet.create(&#x27;getLabel&#x27;, {}, this.source);
      labelRequest.target = msg.target;
      this.send(labelRequest);

      this.emit(&#x27;bulb-new&#x27;, lightDevice); // deprecated
      this.emit(&#x27;light-new&#x27;, lightDevice);
    } else {
      if (this.devices[msg.target].status === &#x27;off&#x27;) {
        this.devices[msg.target].status = &#x27;on&#x27;;
        this.emit(&#x27;bulb-online&#x27;, this.devices[msg.target]); // deprecated
        this.emit(&#x27;light-online&#x27;, this.devices[msg.target]);
      }
      this.devices[msg.target].address = rinfo.address;
      this.devices[msg.target].seenOnDiscovery = this.discoveryPacketSequence;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  address: &#x27;192.168.2.108&#x27;,
  family: &#x27;IPv4&#x27;,
  port: 56700,
  size: 41
};
let currDeviceCount = getDeviceCount();
let currMsgQueCnt = getMsgQueueLength();
client.<span class="apidocCodeKeywordSpan">processDiscoveryPacket</span>(new Error(), null, null);
client.processDiscoveryPacket(null, {
  service: &#x27;udp&#x27;,
  port: 8080
}, null);
assert.equal(currDeviceCount, getDeviceCount(), &#x27;malformed packages ignored&#x27;);
assert.equal(currMsgQueCnt, getMsgQueueLength(), &#x27;malformed packages ignored&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.processLabelPacket" id="apidoc.element.node-lifx.Client.prototype.processLabelPacket">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>processLabelPacket
        <span class="apidocSignatureSpan">(err, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processLabelPacket = function (err, msg) {
  if (err) {
    return;
  }
  if (this.devices[msg.target] !== undefined) {
    this.devices[msg.target].label = msg.label;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.processMessageHandlers" id="apidoc.element.node-lifx.Client.prototype.processMessageHandlers">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>processMessageHandlers
        <span class="apidocSignatureSpan">(msg, rinfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processMessageHandlers = function (msg, rinfo) {
  // Process only packages for us
  if (msg.source.toLowerCase() !== this.source.toLowerCase()) {
    return;
  }
  // We check our message handler if the answer received is requested
  this.messageHandlers.forEach(function(handler, hdlrIndex) {
    if (msg.type === handler.type) {
      if (handler.sequenceNumber !== undefined) {
        if (handler.sequenceNumber === msg.sequence) {
          // Remove if specific packet was request, since it should only be called once
          this.messageHandlers.splice(hdlrIndex, 1);
          this.messagesQueue.forEach(function(packet, packetIndex) {
            if (packet.transactionType === constants.PACKET_TRANSACTION_TYPES.REQUEST_RESPONSE &#x26;&#x26;
                packet.sequence === msg.sequence) {
              this.messagesQueue.splice(packetIndex, 1);
            }
          }.bind(this));

          // Call the function requesting the packet
          return handler.callback(null, msg, rinfo);
        }
      } else {
        // Call the function requesting the packet
        return handler.callback(null, msg, rinfo);
      }
    }

    // We want to call expired request handlers for specific packages after the
    // messageHandlerTimeout set in options, to specify an error
    if (handler.sequenceNumber !== undefined) {
      if (Date.now() &#x3e; (handler.timestamp + this.messageHandlerTimeout)) {
        this.messageHandlers.splice(hdlrIndex, 1);

        var err = new Error(&#x27;No LIFX response in time&#x27;);
        return handler.callback(err, null, null);
      }
    }
  }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    // Convert type before emitting
    var messageTypeName = _.result(_.find(Packet.typeList, {id: parsedMsg.type}), &#x27;name&#x27;);
    if (messageTypeName !== undefined) {
      parsedMsg.type = messageTypeName;
    }
    // Check for handlers of given message and rinfo
    this.<span class="apidocCodeKeywordSpan">processMessageHandlers</span>(parsedMsg, rinfo);

    this.emit(&#x27;message&#x27;, parsedMsg, rinfo);
  }
}.bind(this));

this.socket.bind(opts.port, opts.address, function() {
  this.isSocketBound = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.send" id="apidoc.element.node-lifx.Client.prototype.send">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>send
        <span class="apidocSignatureSpan">(msg, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (msg, callback) {
  var packet = {
    timeCreated: Date.now(),
    timeLastSent: 0,
    timesSent: 0,
    transactionType: constants.PACKET_TRANSACTION_TYPES.ONE_WAY
  };

  // Add the target ip address if target given
  if (msg.address !== undefined) {
    packet.address = msg.address;
  }
  if (msg.target !== undefined) {
    var targetBulb = this.light(msg.target);
    if (targetBulb) {
      packet.address = targetBulb.address;
      // If we would exceed the max value for the int8 field start over again
      if (this.sequenceNumber &#x3e;= constants.PACKET_HEADER_SEQUENCE_MAX) {
        this.sequenceNumber = 0;
      } else {
        this.sequenceNumber += 1;
      }
    }
  }

  msg.sequence = this.sequenceNumber;
  packet.sequence = this.sequenceNumber;
  if (typeof callback === &#x27;function&#x27;) {
    msg.ackRequired = true;
    this.addMessageHandler(&#x27;acknowledgement&#x27;, callback, msg.sequence);
    packet.transactionType = constants.PACKET_TRANSACTION_TYPES.REQUEST_RESPONSE;
  }
  packet.data = Packet.toBuffer(msg);
  this.messagesQueue.unshift(packet);
  this.startSendingProcess();

  return this.sequenceNumber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (this.messagesQueue.length &#x3e; 0) {
var msg = this.messagesQueue.pop();
if (msg.address === undefined) {
  msg.address = this.broadcastAddress;
}
if (msg.transactionType === constants.PACKET_TRANSACTION_TYPES.ONE_WAY) {
  this.socket.<span class="apidocCodeKeywordSpan">send</span>(msg.data, 0, msg.data.length, this.port, msg.address);
  /* istanbul ignore if  */
  if (this.debug) {
    console.log(&#x27;DEBUG - &#x27; + msg.data.toString(&#x27;hex&#x27;) + &#x27; to &#x27; + msg.address);
  }
} else if (msg.transactionType === constants.PACKET_TRANSACTION_TYPES.REQUEST_RESPONSE) {
  if (msg.timesSent &#x3c; this.resendMaxTimes) {
    if (Date.now() &#x3e; (msg.timeLastSent + this.resendPacketDelay)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.sendingProcess" id="apidoc.element.node-lifx.Client.prototype.sendingProcess">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>sendingProcess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendingProcess = function () {
  if (!this.isSocketBound) {
    this.stopSendingProcess();
    console.log(&#x27;LIFX Client stopped sending due to unbound socket&#x27;);
    return;
  }

  if (this.messagesQueue.length &#x3e; 0) {
    var msg = this.messagesQueue.pop();
    if (msg.address === undefined) {
      msg.address = this.broadcastAddress;
    }
    if (msg.transactionType === constants.PACKET_TRANSACTION_TYPES.ONE_WAY) {
      this.socket.send(msg.data, 0, msg.data.length, this.port, msg.address);
<span class="apidocCodeCommentSpan">      /* istanbul ignore if  */
</span>      if (this.debug) {
        console.log(&#x27;DEBUG - &#x27; + msg.data.toString(&#x27;hex&#x27;) + &#x27; to &#x27; + msg.address);
      }
    } else if (msg.transactionType === constants.PACKET_TRANSACTION_TYPES.REQUEST_RESPONSE) {
      if (msg.timesSent &#x3c; this.resendMaxTimes) {
        if (Date.now() &#x3e; (msg.timeLastSent + this.resendPacketDelay)) {
          this.socket.send(msg.data, 0, msg.data.length, this.port, msg.address);
          msg.timesSent += 1;
          msg.timeLastSent = Date.now();
          /* istanbul ignore if  */
          if (this.debug) {
            console.log(
              &#x27;DEBUG - &#x27; + msg.data.toString(&#x27;hex&#x27;) + &#x27; to &#x27; + msg.address +
              &#x27;, send &#x27; + msg.timesSent + &#x27; time(s)&#x27;
            );
          }
        }
        // Add to the end of the queue again
        this.messagesQueue.unshift(msg);
      } else {
        this.messageHandlers.forEach(function(handler, hdlrIndex) {
          if (handler.type === &#x27;acknowledgement&#x27; &#x26;&#x26; handler.sequenceNumber === msg.sequence) {
            this.messageHandlers.splice(hdlrIndex, 1);
            var err = new Error(&#x27;No LIFX response after max resend limit of &#x27; + this.resendMaxTimes);
            return handler.callback(err, null, null);
          }
        }.bind(this));
      }
    }
  } else {
    this.stopSendingProcess();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new Error();
  };

  client.init({
    startDiscovery: false
  }, () =&#x3e; {
    client.socket.on(&#x27;message&#x27;, shouldNotBeCalled);
    client.<span class="apidocCodeKeywordSpan">sendingProcess</span>();
    assert.isNull(client.sendTimer);
    client.socket.removeListener(&#x27;message&#x27;, shouldNotBeCalled);
    done();
  });
});

test(&#x27;with new single one way packet in queue&#x27;, (done) =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.setDebug" id="apidoc.element.node-lifx.Client.prototype.setDebug">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>setDebug
        <span class="apidocSignatureSpan">(debug)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDebug = function (debug) {
  if (typeof debug !== &#x27;boolean&#x27;) {
    throw new TypeError(&#x27;LIFX Client setDebug expects boolean as parameter&#x27;);
  }
  this.debug = debug;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (err) {
        console.log(&#x27;Turning light &#x27; + light.id + &#x27; bright reddish white failed&#x27;);
      }
      console.log(&#x27;Turned light &#x27; + light.id + &#x27; bright reddish white&#x27;);
    });
  });
} else if (key === &#x27;8&#x27;) {
  client.<span class="apidocCodeKeywordSpan">setDebug</span>(true);
  console.log(&#x27;Debug messages are shown&#x27;);
} else if (key === &#x27;9&#x27;) {
  client.setDebug(false);
  console.log(&#x27;Debug messages are hidden&#x27;);
} else if (key === &#x27;\u0003&#x27; || key === &#x27;0&#x27;) { // Ctrl + C
  client.destroy();
  process.exit(); // eslint-disable-line no-process-exit
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.startDiscovery" id="apidoc.element.node-lifx.Client.prototype.startDiscovery">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>startDiscovery
        <span class="apidocSignatureSpan">(lights)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startDiscovery = function (lights) {
  lights = lights || [];
  var sendDiscoveryPacket = function() {
    // Sign flag on inactive lights
    _.forEach(this.devices, _.bind(function(info, deviceId) {
      if (this.devices[deviceId].status !== &#x27;off&#x27;) {
        var diff = this.discoveryPacketSequence - info.seenOnDiscovery;
        if (diff &#x3e;= this.lightOfflineTolerance) {
          this.devices[deviceId].status = &#x27;off&#x27;;
          this.emit(&#x27;bulb-offline&#x27;, info); // deprecated
          this.emit(&#x27;light-offline&#x27;, info);
        }
      }
    }, this));

    // Send a discovery packet broadcast
    this.send(Packet.create(&#x27;getService&#x27;, {}, this.source));

    // Send a discovery packet to each light given directly
    lights.forEach(function(lightAddress) {
      var msg = Packet.create(&#x27;getService&#x27;, {}, this.source);
      msg.address = lightAddress;
      this.send(msg);
    }, this);

    // Keep track of a sequent number to find not answering lights
    if (this.discoveryPacketSequence &#x3e;= Number.MAX_VALUE) {
      this.discoveryPacketSequence = 0;
    } else {
      this.discoveryPacketSequence += 1;
    }
  }.bind(this);

  this.discoveryTimer = setInterval(
    sendDiscoveryPacket,
    constants.DISCOVERY_INTERVAL
  );

  sendDiscoveryPacket();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### `light-online`
This event is thrown when a light is discovered again after being offline.
`client.on(&#x27;light-online&#x27;, function(light) {});`

### Start / Stop discovery
The discovery for each client can be started and stopped at runtime using these commands:

#### `client.<span class="apidocCodeKeywordSpan">startDiscovery</span>()`
Starts the discovery process.

#### `client.stopDiscovery()`
Stops the discovery process.

### Client settings
For the initialization of the client different settings can be provided. This is an example with the default options:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.startSendingProcess" id="apidoc.element.node-lifx.Client.prototype.startSendingProcess">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>startSendingProcess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startSendingProcess = function () {
  if (this.sendTimer === null) { // Already running?
    this.sendTimer = setInterval(this.sendingProcess.bind(this), constants.MESSAGE_RATE_LIMIT);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 if (typeof callback === &#x27;function&#x27;) {
   msg.ackRequired = true;
   this.addMessageHandler(&#x27;acknowledgement&#x27;, callback, msg.sequence);
   packet.transactionType = constants.PACKET_TRANSACTION_TYPES.REQUEST_RESPONSE;
 }
 packet.data = Packet.toBuffer(msg);
 this.messagesQueue.unshift(packet);
 this.<span class="apidocCodeKeywordSpan">startSendingProcess</span>();

 return this.sequenceNumber;
};

/**
* Get network address data from connection
* @return {Object} Network address data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.stopDiscovery" id="apidoc.element.node-lifx.Client.prototype.stopDiscovery">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>stopDiscovery
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopDiscovery = function () {
  clearInterval(this.discoveryTimer);
  this.discoveryTimer = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Start / Stop discovery
The discovery for each client can be started and stopped at runtime using these commands:

#### `client.startDiscovery()`
Starts the discovery process.

#### `client.<span class="apidocCodeKeywordSpan">stopDiscovery</span>()`
Stops the discovery process.

### Client settings
For the initialization of the client different settings can be provided. This is an example with the default options:

```js
var LifxClient = require(&#x27;node-lifx&#x27;).Client;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.prototype.stopSendingProcess" id="apidoc.element.node-lifx.Client.prototype.stopSendingProcess">
        function <span class="apidocSignatureSpan">node-lifx.Client.prototype.</span>stopSendingProcess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopSendingProcess = function () {
  if (this.sendTimer !== null) {
    clearInterval(this.sendTimer);
    this.sendTimer = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Destroy an instance
*/
Client.prototype.destroy = function() {
 this.stopDiscovery();
 this.<span class="apidocCodeKeywordSpan">stopSendingProcess</span>();
 if (this.isSocketBound) {
   this.socket.close();
 }
};

/**
* Sends a packet from the messages queue or stops the sending process
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-lifx.Client.super_" id="apidoc.module.node-lifx.Client.super_">module node-lifx.Client.super_</a></h1>




    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.super_" id="apidoc.element.node-lifx.Client.super_.super_">
        function <span class="apidocSignatureSpan">node-lifx.Client.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.EventEmitter" id="apidoc.element.node-lifx.Client.super_.EventEmitter">
        function <span class="apidocSignatureSpan">node-lifx.Client.super_.</span>EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-lifx.Client.super_.prototype" id="apidoc.module.node-lifx.Client.super_.prototype">module node-lifx.Client.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.prototype.addListener" id="apidoc.element.node-lifx.Client.super_.prototype.addListener">
        function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>addListener
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.prototype.emit" id="apidoc.element.node-lifx.Client.super_.prototype.emit">
        function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>emit
        <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i &#x3c; len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i &#x3c; length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j &#x3c; len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

this.socket.on(&#x27;error&#x27;, function(err) {
  this.isSocketBound = false;
  console.error(&#x27;LIFX Client UDP error&#x27;);
  console.trace(err);
  this.socket.close();
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;error&#x27;, err);
}.bind(this));

this.socket.on(&#x27;message&#x27;, function(msg, rinfo) {
  // Ignore own messages and false formats
  if (utils.getHostIPs().indexOf(rinfo.address) &#x3e;= 0 || !Buffer.isBuffer(msg)) {
    return;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.prototype.eventNames" id="apidoc.element.node-lifx.Client.super_.prototype.eventNames">
        function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.prototype.listeners" id="apidoc.element.node-lifx.Client.super_.prototype.listeners">
        function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>listeners
        <span class="apidocSignatureSpan">(event, exists)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i &#x3c; l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.prototype.off" id="apidoc.element.node-lifx.Client.super_.prototype.off">
        function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>off
        <span class="apidocSignatureSpan">(event, fn, context, once)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
         listeners.fn === fn
      &#x26;&#x26; (!once || listeners.once)
      &#x26;&#x26; (!context || listeners.context === context)
    ) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i &#x3c; length; i++) {
      if (
           listeners[i].fn !== fn
        || (once &#x26;&#x26; !listeners[i].once)
        || (context &#x26;&#x26; listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Usage examples:
```js
light.on(); // Turns the light on instantly
light.on(2000); // Fading the light on over two seconds
```

#### `light.<span class="apidocCodeKeywordSpan">off</span>([duration], [callback])`
This turns a light off.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`duration` | int | 0 | Turning off will be faded over the time (in milliseconds).
`callback` | function | null | `function(error) {}` Called after the command has reached the light or after `client.resendMaxTimes
` with `client.resendPacketDelay` in case it has not. `error` is `null` in case of success and given if the sending has failed.
_Note: Using callback multiplies network load for this command by two or more times._
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.prototype.on" id="apidoc.element.node-lifx.Client.super_.prototype.on">
        function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>on
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


&#x27;use strict&#x27;;

var Lifx = require(&#x27;./lib/lifx&#x27;).Client;
var client = new Lifx();

client.<span class="apidocCodeKeywordSpan">on</span>(&#x27;error&#x27;, function(err) {
console.log(&#x27;LIFX error:\n&#x27; + err.stack);
client.destroy();
});

client.on(&#x27;message&#x27;, function(msg, rinfo) {
if (typeof msg.type === &#x27;string&#x27;) {
  // Known packages send by the lights as broadcast
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.prototype.once" id="apidoc.element.node-lifx.Client.super_.prototype.once">
        function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>once
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.prototype.removeAllListeners" id="apidoc.element.node-lifx.Client.super_.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.prototype.removeListener" id="apidoc.element.node-lifx.Client.super_.prototype.removeListener">
        function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(event, fn, context, once)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
         listeners.fn === fn
      &#x26;&#x26; (!once || listeners.once)
      &#x26;&#x26; (!context || listeners.context === context)
    ) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i &#x3c; length; i++) {
      if (
           listeners[i].fn !== fn
        || (once &#x26;&#x26; !listeners[i].once)
        || (context &#x26;&#x26; listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  client.init({
    startDiscovery: false
  }, () =&#x3e; {
    client.socket.on(&#x27;message&#x27;, shouldNotBeCalled);
    client.sendingProcess();
    assert.isNull(client.sendTimer);
    client.socket.<span class="apidocCodeKeywordSpan">removeListener</span>(&#x27;message&#x27;, shouldNotBeCalled);
    done();
  });
});

test(&#x27;with new single one way packet in queue&#x27;, (done) =&#x3e; {
  const packetSendCallback = (msg, rinfo) =&#x3e; {
    if (msg === undefined || rinfo === undefined) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Client.super_.prototype.setMaxListeners" id="apidoc.element.node-lifx.Client.super_.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">node-lifx.Client.super_.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners() {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-lifx.Light" id="apidoc.module.node-lifx.Light">module node-lifx.Light</a></h1>


    <h2>
        <a href="#apidoc.element.node-lifx.Light.Light" id="apidoc.element.node-lifx.Light.Light">
        function <span class="apidocSignatureSpan">node-lifx.</span>Light
        <span class="apidocSignatureSpan">(constr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Light(constr) {
  this.client = constr.client;
  this.id = constr.id; // Used to target the light
  this.address = constr.address;
  this.port = constr.port;
  this.label = null;
  this.status = &#x27;on&#x27;;

  this.seenOnDiscovery = constr.seenOnDiscovery;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-lifx.Light.prototype" id="apidoc.module.node-lifx.Light.prototype">module node-lifx.Light.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.color" id="apidoc.element.node-lifx.Light.prototype.color">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>color
        <span class="apidocSignatureSpan">(hue, saturation, brightness, kelvin, duration, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">color = function (hue, saturation, brightness, kelvin, duration, callback) {
  if (typeof hue !== &#x27;number&#x27; || hue &#x3c; constants.HSBK_MINIMUM_HUE || hue &#x3e; constants.HSBK_MAXIMUM_HUE) {
    throw new RangeError(&#x27;LIFX light color method expects hue to be a number between &#x27; +
      constants.HSBK_MINIMUM_HUE + &#x27; and &#x27; + constants.HSBK_MAXIMUM_HUE
    );
  }
  hue = Math.round(hue / constants.HSBK_MAXIMUM_HUE * 65535);

  if (typeof saturation !== &#x27;number&#x27; || saturation &#x3c; constants.HSBK_MINIMUM_SATURATION || saturation &#x3e; constants.HSBK_MAXIMUM_SATURATION
) {
    throw new RangeError(&#x27;LIFX light color method expects saturation to be a number between &#x27; +
      constants.HSBK_MINIMUM_SATURATION + &#x27; and &#x27; + constants.HSBK_MAXIMUM_SATURATION
    );
  }
  saturation = Math.round(saturation / constants.HSBK_MAXIMUM_SATURATION * 65535);

  if (typeof brightness !== &#x27;number&#x27; || brightness &#x3c; constants.HSBK_MINIMUM_BRIGHTNESS || brightness &#x3e; constants.HSBK_MAXIMUM_BRIGHTNESS
) {
    throw new RangeError(&#x27;LIFX light color method expects brightness to be a number between &#x27; +
      constants.HSBK_MINIMUM_BRIGHTNESS + &#x27; and &#x27; + constants.HSBK_MAXIMUM_BRIGHTNESS
    );
  }
  brightness = Math.round(brightness / constants.HSBK_MAXIMUM_BRIGHTNESS * 65535);

  if (duration !== undefined &#x26;&#x26; typeof duration !== &#x27;number&#x27;) {
    throw new RangeError(&#x27;LIFX light color method expects duration to be a number&#x27;);
  }

  if (callback !== undefined &#x26;&#x26; typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light color method expects callback to be a function&#x27;);
  }

  var packetObj = packet.create(&#x27;setColor&#x27;, {
    hue: hue,
    saturation: saturation,
    brightness: brightness,
    kelvin: kelvin,
    duration: duration
  }, this.client.source);
  packetObj.target = this.id;
  this.client.send(packetObj, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Usage examples:
```js
light.off(); // Turns the light off instantly
light.off(2000); // Fading the light off over two seconds
```

#### `light.<span class="apidocCodeKeywordSpan">color</span>(hue, saturation, brightness, [kelvin], [duration], [callback])`
Changes the color of a light to an HSB color value. This is the preferred method to change the color of a light.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`hue` | int | | Between 0 and 360, representing the color hue in degree which changes the color.
`saturation` | int | | Between 0 and 100, representing the color intensity from 0% to 100%.
`brightness` | int | | Between 0 and 100, representing the light brightness from 0% to 100%.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.colorRgb" id="apidoc.element.node-lifx.Light.prototype.colorRgb">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>colorRgb
        <span class="apidocSignatureSpan">(red, green, blue, duration, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">colorRgb = function (red, green, blue, duration, callback) {
  if (typeof red !== &#x27;number&#x27;) {
    throw new TypeError(&#x27;LIFX light colorRgb method expects first parameter red to a number&#x27;);
  }
  if (red &#x3c; constants.RGB_MINIMUM_VALUE || red &#x3e; constants.RGB_MAXIMUM_VALUE) {
    throw new RangeError(&#x27;LIFX light colorRgb method expects first parameter red to be between 0 and 255&#x27;);
  }
  if (typeof green !== &#x27;number&#x27;) {
    throw new TypeError(&#x27;LIFX light colorRgb method expects second parameter green to a number&#x27;);
  }
  if (green &#x3c; constants.RGB_MINIMUM_VALUE || green &#x3e; constants.RGB_MAXIMUM_VALUE) {
    throw new RangeError(&#x27;LIFX light colorRgb method expects second parameter green to be between 0 and 255&#x27;);
  }
  if (typeof blue !== &#x27;number&#x27;) {
    throw new TypeError(&#x27;LIFX light colorRgb method expects third parameter blue to a number&#x27;);
  }
  if (blue &#x3c; constants.RGB_MINIMUM_VALUE || blue &#x3e; constants.RGB_MAXIMUM_VALUE) {
    throw new RangeError(&#x27;LIFX light colorRgb method expects third parameter blue to be between 0 and 255&#x27;);
  }

  if (duration !== undefined &#x26;&#x26; typeof duration !== &#x27;number&#x27;) {
    throw new RangeError(&#x27;LIFX light colorRgb method expects duration to be a number&#x27;);
  }

  if (callback !== undefined &#x26;&#x26; typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light colorRgb method expects callback to be a function&#x27;);
  }

  var hsbObj = utils.rgbToHsb({r: red, g: green, b: blue});
  this.color(hsbObj.h, hsbObj.s, hsbObj.b, 3500, duration, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Usage examples:
```js
light.colorRgbHex(&#x27;#F00&#x27;); // Set to red
light.colorRgbHex(&#x27;#FFFF00&#x27;); // Set to yellow
```

#### `light.<span class="apidocCodeKeywordSpan">colorRgb</span>(red, green, blue, [duration], [callback])`
Changes the color of a light to an RGB color value. Note that RGB poorly represents color of light,
prefer HSBK values given via the `color` method.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`red` | int | | Amout of red in color from 0 to 255
`green` | int | | Amout of green in color from 0 to 255
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.colorRgbHex" id="apidoc.element.node-lifx.Light.prototype.colorRgbHex">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>colorRgbHex
        <span class="apidocSignatureSpan">(hexString, duration, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">colorRgbHex = function (hexString, duration, callback) {
  if (typeof hexString !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;LIFX light colorRgbHex method expects first parameter hexString to a string&#x27;);
  }

  if (duration !== undefined &#x26;&#x26; typeof duration !== &#x27;number&#x27;) {
    throw new RangeError(&#x27;LIFX light colorRgbHex method expects duration to be a number&#x27;);
  }

  if (callback !== undefined &#x26;&#x26; typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light colorRgbHex method expects callback to be a function&#x27;);
  }

  var rgbObj = utils.rgbHexStringToObject(hexString);
  var hsbObj = utils.rgbToHsb(rgbObj);
  this.color(hsbObj.h, hsbObj.s, hsbObj.b, 3500, duration, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Usage examples:
```js
light.color(0, 100, 50); // Set to red at 50% brightness
light.color(50, 50, 80, 3500, 2000); // Set to a light green at 80% brightness over next two seconds
```

#### `light.<span class="apidocCodeKeywordSpan">colorRgbHex</span>(hexString, [duration], [callback])`
Changes the color of a light to an RGB color value given in Hex Format. Note that RGB poorly represents color of light,
prefer HSBK values given via the `color` method.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`hexString` | string | | A hex RGB string starting with `#`
`duration` | int | 0 | Fade the color to the new value over time (in milliseconds).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.getAmbientLight" id="apidoc.element.node-lifx.Light.prototype.getAmbientLight">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getAmbientLight
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAmbientLight = function (callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light getAmbientLight method expects callback to be a function&#x27;);
  }
  var packetObj = packet.create(&#x27;getAmbientLight&#x27;, {}, this.client.source);
  packetObj.target = this.id;
  var sqnNumber = this.client.send(packetObj);
  this.client.addMessageHandler(&#x27;stateAmbientLight&#x27;, function(err, msg) {
    if (err) {
      return callback(err, null);
    }
    return callback(null, msg.flux);
  }, sqnNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
null,
{
  majorVersion: 2,
  minorVersion: 1
}
```

#### `light.<span class="apidocCodeKeywordSpan">getAmbientLight</span>(callback)`
Requests the ambient light value in flux from the light. This function is asynchronous.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`callback` | function | | `function(error, data) {}`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.getFirmwareInfo" id="apidoc.element.node-lifx.Light.prototype.getFirmwareInfo">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getFirmwareInfo
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirmwareInfo = function (callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light getFirmwareVersion method expects callback to be a function&#x27;);
  }
  var packetObj = packet.create(&#x27;getHostInfo&#x27;, {}, this.client.source);
  packetObj.target = this.id;
  var sqnNumber = this.client.send(packetObj);
  this.client.addMessageHandler(&#x27;stateHostInfo&#x27;, function(err, msg) {
    if (err) {
      return callback(err, null);
    }
    callback(null, _.pick(msg, [
      &#x27;signal&#x27;,
      &#x27;tx&#x27;,
      &#x27;rx&#x27;
    ]));
  }, sqnNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    color: true,
    infrared: false,
    multizone: false
  }
}
```

#### `light.<span class="apidocCodeKeywordSpan">getFirmwareInfo</span>(callback)`
Requests info from the micro controller unit of a light (signal, tx and rx). This function is asynchronous.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`callback` | function | | `function(error, data) {}`

Example result:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.getFirmwareVersion" id="apidoc.element.node-lifx.Light.prototype.getFirmwareVersion">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getFirmwareVersion
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirmwareVersion = function (callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light getFirmwareVersion method expects callback to be a function&#x27;);
  }
  var packetObj = packet.create(&#x27;getHostFirmware&#x27;, {}, this.client.source);
  packetObj.target = this.id;
  var sqnNumber = this.client.send(packetObj);
  this.client.addMessageHandler(&#x27;stateHostFirmware&#x27;, function(err, msg) {
    if (err) {
      return callback(err, null);
    }
    callback(null, _.pick(msg, [
      &#x27;majorVersion&#x27;,
      &#x27;minorVersion&#x27;
    ]));
  }, sqnNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example result:
```js
null,
0 // off
```

#### `light.<span class="apidocCodeKeywordSpan">getFirmwareVersion</span>(callback)`
Requests the firmware version from a light (minor and major version). This function is asynchronous.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`callback` | function | | `function(error, data) {}`

Example result:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.getHardwareVersion" id="apidoc.element.node-lifx.Light.prototype.getHardwareVersion">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getHardwareVersion
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHardwareVersion = function (callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light getHardwareVersion method expects callback to be a function&#x27;);
  }
  var packetObj = packet.create(&#x27;getVersion&#x27;, {}, this.client.source);
  packetObj.target = this.id;
  var sqnNumber = this.client.send(packetObj);
  this.client.addMessageHandler(&#x27;stateVersion&#x27;, function(err, msg) {
    if (err) {
      return callback(err, null);
    }
    var versionInfo = _.pick(msg, [
      &#x27;vendorId&#x27;,
      &#x27;productId&#x27;,
      &#x27;version&#x27;
    ]);
    callback(null, _.assign(
      versionInfo,
      utils.getHardwareDetails(versionInfo.vendorId, versionInfo.productId)
    ));
  }, sqnNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
null,
{
  majorVersion: 2,
  minorVersion: 1
}
```

#### `light.<span class="apidocCodeKeywordSpan">getHardwareVersion</span>(callback)`
Requests the hardware version from a light (vendor, product and version). This function is asynchronous.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`callback` | function | | `function(error, data) {}`

Example result:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.getLabel" id="apidoc.element.node-lifx.Light.prototype.getLabel">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getLabel
        <span class="apidocSignatureSpan">(callback, cache)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLabel = function (callback, cache) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light getLabel method expects callback to be a function&#x27;);
  }
  if (cache !== undefined &#x26;&#x26; typeof cache !== &#x27;boolean&#x27;) {
    throw new TypeError(&#x27;LIFX light getLabel method expects cache to be a boolean&#x27;);
  }
  if (cache === true) {
    if (typeof this.label === &#x27;string&#x27; &#x26;&#x26; this.label.length &#x3e; 0) {
      return callback(null, this.label);
    }
  }
  var packetObj = packet.create(&#x27;getLabel&#x27;, {
    target: this.id
  }, this.client.source);
  var sqnNumber = this.client.send(packetObj);
  this.client.addMessageHandler(&#x27;stateLabel&#x27;, function(err, msg) {
    if (err) {
      return callback(err, null);
    }
    return callback(null, msg.label);
  }, sqnNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
null,
10
```

### Labels
Labels of lights can be requested and set using the following methods:

#### `light.<span class="apidocCodeKeywordSpan">getLabel</span>(callback, [cache])`
Requests the label of a light. This function is asynchronous.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`callback` | function | | `function(error, data) {}`
`cache`    | boolean  | false | Use the last known value for the label and and do not request from the light again
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.getMaxIR" id="apidoc.element.node-lifx.Light.prototype.getMaxIR">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getMaxIR
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxIR = function (callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light getMaxIR method expects callback to be a function&#x27;);
  }
  var packetObj = packet.create(&#x27;getInfrared&#x27;, {}, this.client.source);
  packetObj.target = this.id;
  var sqnNumber = this.client.send(packetObj);
  this.client.addMessageHandler(&#x27;stateInfrared&#x27;, function(err, msg) {
    if (err) {
      return callback(err, null);
    }

    msg.brightness = Math.round(msg.brightness * (constants.HSBK_MAXIMUM_BRIGHTNESS / 65535));

    callback(null, msg.brightness);
  }, sqnNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Usage examples:
```js
light.maxIR(0); // Set&#x27;s a maximum infrared brightness of 0
light.maxIR(25); // Set&#x27;s a maximum infrared brightness of 25
```

#### `light.<span class="apidocCodeKeywordSpan">getMaxIR</span>(callback)`
Requests the maximum infrared brightness of the light (only for lights that support infrared light)

Option | Type | Default | Description
------ | ---- | ------- | -----------
`callback` | function | | `function(error, data) {}`

Example result:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.getPower" id="apidoc.element.node-lifx.Light.prototype.getPower">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getPower
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPower = function (callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light getPower method expects callback to be a function&#x27;);
  }
  var packetObj = packet.create(&#x27;getPower&#x27;, {}, this.client.source);
  packetObj.target = this.id;
  var sqnNumber = this.client.send(packetObj);
  this.client.addMessageHandler(&#x27;statePower&#x27;, function(err, msg) {
    if (err) {
      return callback(err, null);
    }
    if (msg.level === 65535) {
      msg.level = 1;
    }
    return callback(null, msg.level);
  }, sqnNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
{
  color: { hue: 120, saturation: 0, brightness: 100, kelvin: 8994 },
  power: 0,
  label: &#x27;Kitchen&#x27;
}
```

#### `light.<span class="apidocCodeKeywordSpan">getPower</span>(callback)`
Requests current power state (on or off). This function is asynchronous.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`callback` | function | | `function(error, data) {}`

Example result:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.getState" id="apidoc.element.node-lifx.Light.prototype.getState">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getState
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getState = function (callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light getState method expects callback to be a function&#x27;);
  }
  var packetObj = packet.create(&#x27;getLight&#x27;, {}, this.client.source);
  packetObj.target = this.id;
  var sqnNumber = this.client.send(packetObj);
  this.client.addMessageHandler(&#x27;stateLight&#x27;, function(err, msg) {
    if (err) {
      return callback(err, null);
    }
    // Convert HSB to readable format
    msg.color.hue = Math.round(msg.color.hue * (constants.HSBK_MAXIMUM_HUE / 65535));
    msg.color.saturation = Math.round(msg.color.saturation * (constants.HSBK_MAXIMUM_SATURATION / 65535));
    msg.color.brightness = Math.round(msg.color.brightness * (constants.HSBK_MAXIMUM_BRIGHTNESS / 65535));
    // Convert power to readable format
    if (msg.power === 65535) {
      msg.power = 1;
    }
    callback(null, {
      color: msg.color,
      power: msg.power,
      label: msg.label
    });
  }, sqnNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
```


### Requesting light state and info
Infos of the state and spec of the light can be requested with the following methods:

#### `light.<span class="apidocCodeKeywordSpan">getState</span>(callback)`
Requests general info from a light, this includes color, label and power state. This function is asynchronous.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`callback` | function | | `function(error, data) {}`

Example result:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.getWifiInfo" id="apidoc.element.node-lifx.Light.prototype.getWifiInfo">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getWifiInfo
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getWifiInfo = function (callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light getFirmwareVersion method expects callback to be a function&#x27;);
  }
  var packetObj = packet.create(&#x27;getWifiInfo&#x27;, {}, this.client.source);
  packetObj.target = this.id;
  var sqnNumber = this.client.send(packetObj);
  this.client.addMessageHandler(&#x27;stateWifiInfo&#x27;, function(err, msg) {
    if (err) {
      return callback(err, null);
    }
    callback(null, _.pick(msg, [
      &#x27;signal&#x27;,
      &#x27;tx&#x27;,
      &#x27;rx&#x27;
    ]));
  }, sqnNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
{
  signal: 0,
  tx: 0,
  rx: 0
}
```

#### `light.<span class="apidocCodeKeywordSpan">getWifiInfo</span>(callback)`
Requests wifi info from a light (signal, tx and rx). This function is asynchronous.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`callback` | function | | `function(error, data) {}`

Example result:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.getWifiVersion" id="apidoc.element.node-lifx.Light.prototype.getWifiVersion">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>getWifiVersion
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getWifiVersion = function (callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light getFirmwareVersion method expects callback to be a function&#x27;);
  }
  var packetObj = packet.create(&#x27;getWifiFirmware&#x27;, {}, this.client.source);
  packetObj.target = this.id;
  var sqnNumber = this.client.send(packetObj);
  this.client.addMessageHandler(&#x27;stateWifiFirmware&#x27;, function(err, msg) {
    if (err) {
      return callback(err, null);
    }
    return callback(null, _.pick(msg, [
      &#x27;majorVersion&#x27;,
      &#x27;minorVersion&#x27;
    ]));
  }, sqnNumber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
{
  signal: 0.000009999999747378752,
  tx: 16584,
  rx: 12580
}
```

#### `light.<span class="apidocCodeKeywordSpan">getWifiVersion</span>(callback)`
Requests the wifi firmware version from the light (minor and major version). This function is asynchronous.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`callback` | function | | `function(error, data) {}`

Example result:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.maxIR" id="apidoc.element.node-lifx.Light.prototype.maxIR">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>maxIR
        <span class="apidocSignatureSpan">(brightness, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxIR = function (brightness, callback) {
  if (typeof brightness !== &#x27;number&#x27; || brightness &#x3c; constants.IR_MINIMUM_BRIGHTNESS || brightness &#x3e; constants.IR_MAXIMUM_BRIGHTNESS
) {
    throw new RangeError(&#x27;LIFX light setMaxIR method expects brightness to be a number between &#x27; +
      constants.IR_MINIMUM_BRIGHTNESS + &#x27; and &#x27; + constants.IR_MAXIMUM_BRIGHTNESS
    );
  }
  brightness = Math.round(brightness / constants.IR_MAXIMUM_BRIGHTNESS * 65535);

  if (callback !== undefined &#x26;&#x26; typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light setMaxIR method expects callback to be a function&#x27;);
  }

  var packetObj = packet.create(&#x27;setInfrared&#x27;, {
    brightness: brightness
  }, this.client.source);
  packetObj.target = this.id;
  this.client.send(packetObj, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Usage examples:
```js
light.colorRgb(255, 0, 0); // Set to red
light.colorRgb(255, 255, 0); // Set to yellow
```

#### `light.<span class="apidocCodeKeywordSpan">maxIR</span>(brightness, callback)`
Set&#x27;s the maximum infrared brightness of the light (only for lights that support infrared light)

Option | Type | Default | Description
------ | ---- | ------- | -----------
`brightness` | int | | Between 0 and 100, representing the light brightness from 0% to 100%.
`callback` | function | | `function(error, data) {}`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.off" id="apidoc.element.node-lifx.Light.prototype.off">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>off
        <span class="apidocSignatureSpan">(duration, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (duration, callback) {
  if (duration !== undefined &#x26;&#x26; typeof duration !== &#x27;number&#x27;) {
    throw new RangeError(&#x27;LIFX light off method expects duration to be a number&#x27;);
  }
  if (callback !== undefined &#x26;&#x26; typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light off method expects callback to be a function&#x27;);
  }
  var packetObj = packet.create(&#x27;setPower&#x27;, {level: 0, duration: duration}, this.client.source);
  packetObj.target = this.id;
  this.client.send(packetObj, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Usage examples:
```js
light.on(); // Turns the light on instantly
light.on(2000); // Fading the light on over two seconds
```

#### `light.<span class="apidocCodeKeywordSpan">off</span>([duration], [callback])`
This turns a light off.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`duration` | int | 0 | Turning off will be faded over the time (in milliseconds).
`callback` | function | null | `function(error) {}` Called after the command has reached the light or after `client.resendMaxTimes
` with `client.resendPacketDelay` in case it has not. `error` is `null` in case of success and given if the sending has failed.
_Note: Using callback multiplies network load for this command by two or more times._
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.on" id="apidoc.element.node-lifx.Light.prototype.on">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>on
        <span class="apidocSignatureSpan">(duration, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (duration, callback) {
  if (duration !== undefined &#x26;&#x26; typeof duration !== &#x27;number&#x27;) {
    throw new RangeError(&#x27;LIFX light on method expects duration to be a number&#x27;);
  }
  if (callback !== undefined &#x26;&#x26; typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light on method expects callback to be a function&#x27;);
  }
  var packetObj = packet.create(&#x27;setPower&#x27;, {level: 65535, duration: duration}, this.client.source);
  packetObj.target = this.id;
  this.client.send(packetObj, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


&#x27;use strict&#x27;;

var Lifx = require(&#x27;./lib/lifx&#x27;).Client;
var client = new Lifx();

client.<span class="apidocCodeKeywordSpan">on</span>(&#x27;error&#x27;, function(err) {
console.log(&#x27;LIFX error:\n&#x27; + err.stack);
client.destroy();
});

client.on(&#x27;message&#x27;, function(msg, rinfo) {
if (typeof msg.type === &#x27;string&#x27;) {
  // Known packages send by the lights as broadcast
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.Light.prototype.setLabel" id="apidoc.element.node-lifx.Light.prototype.setLabel">
        function <span class="apidocSignatureSpan">node-lifx.Light.prototype.</span>setLabel
        <span class="apidocSignatureSpan">(label, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setLabel = function (label, callback) {
  if (label === undefined || typeof label !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;LIFX light setLabel method expects label to be a string&#x27;);
  }
  if (Buffer.byteLength(label, &#x27;utf8&#x27;) &#x3e; 32) {
    throw new RangeError(&#x27;LIFX light setLabel method expects a maximum of 32 bytes as label&#x27;);
  }
  if (label.length &#x3c; 1) {
    throw new RangeError(&#x27;LIFX light setLabel method expects a minimum of one char as label&#x27;);
  }
  if (callback !== undefined &#x26;&#x26; typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;LIFX light setLabel method expects callback to be a function&#x27;);
  }

  var packetObj = packet.create(&#x27;setLabel&#x27;, {label: label}, this.client.source);
  packetObj.target = this.id;
  this.client.send(packetObj, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example result:
```js
null,
&#x27;Kitchen&#x27;
```

#### `light.<span class="apidocCodeKeywordSpan">setLabel</span>(label, [callback])`
Sets a new label for a light.

Option | Type | Default | Description
------ | ---- | ------- | -----------
`label` | string | | New Label with 32 bit size maximum (which is a length of 32 with non unicode chars).
`callback` | function | null | `function(error) {}` Called after the command has reached the light or after `client.resendMaxTimes
` with `client.resendPacketDelay` in case it has not. `error` is `null` in case of success and given if the sending has failed.
_Note: Using callback multiplies network load for this command by two or more times._
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-lifx.packet" id="apidoc.module.node-lifx.packet">module node-lifx.packet</a></h1>


    <h2>
        <a href="#apidoc.element.node-lifx.packet.create" id="apidoc.element.node-lifx.packet.create">
        function <span class="apidocSignatureSpan">node-lifx.packet.</span>create
        <span class="apidocSignatureSpan">(type, params, source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (type, params, source, target) {
  var obj = {};
  if (type !== undefined) {
    // Check if type is valid
    if (typeof type === &#x27;string&#x27; || type instanceof String) {
      obj.type = _.result(_.find(this.typeList, {name: type}), &#x27;id&#x27;);
    } else if (typeof type === &#x27;number&#x27;) {
      var typeMatch = _.find(this.typeList, {id: type});
      obj.type = _.result(typeMatch, &#x27;id&#x27;);
      type = _.result(typeMatch, &#x27;name&#x27;);
    }
    if (obj.type === undefined) {
      return false;
    }
  } else {
    return false;
  }
  obj.size = constants.PACKET_HEADER_SIZE + packets[type].size;

  if (source !== undefined) {
    obj.source = source;
  }
  if (target !== undefined) {
    obj.target = target;
  }
  if (packets[type].tagged !== undefined) {
    obj.tagged = packets[type].tagged;
  }

  return _.assign(obj, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.emit(&#x27;bulb-offline&#x27;, info); // deprecated
      this.emit(&#x27;light-offline&#x27;, info);
    }
  }
}, this));

// Send a discovery packet broadcast
this.send(Packet.<span class="apidocCodeKeywordSpan">create</span>(&#x27;getService&#x27;, {}, this.source));

// Send a discovery packet to each light given directly
lights.forEach(function(lightAddress) {
  var msg = Packet.create(&#x27;getService&#x27;, {}, this.source);
  msg.address = lightAddress;
  this.send(msg);
}, this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.packet.headerToBuffer" id="apidoc.element.node-lifx.packet.headerToBuffer">
        function <span class="apidocSignatureSpan">node-lifx.packet.</span>headerToBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">headerToBuffer = function (obj) {
  var buf = new Buffer(36);
  buf.fill(0);
  var offset = 0;

  // Frame
  buf.writeUInt16LE(obj.size, offset);
  offset += 2;

  if (obj.protocolVersion === undefined) {
    obj.protocolVersion = constants.PROTOCOL_VERSION_CURRENT;
  }
  var frameDescription = obj.protocolVersion;

  if (obj.addressable !== undefined &#x26;&#x26; obj.addressable === true) {
    frameDescription |= constants.ADDRESSABLE_BIT;
  } else if (obj.source !== undefined &#x26;&#x26; obj.source.length &#x3e; 0 &#x26;&#x26; obj.source !== &#x27;00000000&#x27;) {
    frameDescription |= constants.ADDRESSABLE_BIT;
  }

  if (obj.tagged !== undefined &#x26;&#x26; obj.tagged === true) {
    frameDescription |= constants.TAGGED_BIT;
  }

  if (obj.origin !== undefined &#x26;&#x26; obj.origin === true) {
    // 0 or 1 to the 14 bit
    frameDescription |= (1 &#x3c;&#x3c; 14);
  }

  buf.writeUInt16LE(frameDescription, offset);
  offset += 2;

  if (obj.source !== undefined &#x26;&#x26; obj.source.length &#x3e; 0) {
    if (obj.source.length === 8) {
      buf.write(obj.source, offset, 4, &#x27;hex&#x27;);
    } else {
      throw new RangeError(&#x27;LIFX source must be given in 8 characters&#x27;);
    }
  }
  offset += 4;

  // Frame address
  if (obj.target !== undefined &#x26;&#x26; obj.target !== null) {
    buf.write(obj.target, offset, 6, &#x27;hex&#x27;);
  }
  offset += 6;

  // reserved1
  offset += 2;

  if (obj.site !== undefined &#x26;&#x26; obj.site !== null) {
    buf.write(obj.site, offset, 6, &#x27;utf8&#x27;);
  }
  offset += 6;

  var frameAddressDescription = 0;
  if (obj.ackRequired !== undefined &#x26;&#x26; obj.ackRequired === true) {
    frameAddressDescription |= constants.ACK_REQUIRED_BIT;
  }

  if (obj.resRequired !== undefined &#x26;&#x26; obj.resRequired === true) {
    frameAddressDescription |= constants.RESPONSE_REQUIRED_BIT;
  }
  buf.writeUInt8(frameAddressDescription, offset);
  offset += 1;

  if (typeof obj.sequence === &#x27;number&#x27;) {
    buf.writeUInt8(obj.sequence, offset);
  }
  offset += 1;

  // Protocol header
  if (obj.time !== undefined) {
    utils.writeUInt64LE(buf, offset, obj.time);
  }
  offset += 8;

  if (typeof obj.type === &#x27;number&#x27;) {
    obj.type = _.result(_.find(this.typeList, {id: obj.type}), &#x27;id&#x27;);
  } else if (typeof obj.type === &#x27;string&#x27; || obj.type instanceof String) {
    obj.type = _.result(_.find(this.typeList, {name: obj.type}), &#x27;id&#x27;);
  }
  if (obj.type === undefined) {
    throw new Error(&#x27;Unknown lifx packet of type: &#x27; + obj.type);
  }
  buf.writeUInt16LE(obj.type, offset);
  offset += 2;

  // reserved2
  offset += 2;

  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    obj.type = _.result(_.find(this.typeList, {name: obj.type}), &#x27;name&#x27;);
  }

  if (obj.type !== undefined) {
    if (typeof packets[obj.type].toBuffer === &#x27;function&#x27;) {
      var packetTypeData = packets[obj.type].toBuffer(obj);
      return Buffer.concat([
        this.<span class="apidocCodeKeywordSpan">headerToBuffer</span>(obj),
        packetTypeData
      ]);
    }
    return this.headerToBuffer(obj);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.packet.headerToObject" id="apidoc.element.node-lifx.packet.headerToObject">
        function <span class="apidocSignatureSpan">node-lifx.packet.</span>headerToObject
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">headerToObject = function (buf) {
  var obj = {};
  var offset = 0;

  // Frame
  obj.size = buf.readUInt16LE(offset);
  offset += 2;

  var frameDescription = buf.readUInt16LE(offset);
  obj.addressable = (frameDescription &#x26; constants.ADDRESSABLE_BIT) !== 0;
  obj.tagged = (frameDescription &#x26; constants.TAGGED_BIT) !== 0;
  obj.origin = ((frameDescription &#x26; constants.ORIGIN_BITS) &#x3e;&#x3e; 14) !== 0;
  obj.protocolVersion = (frameDescription &#x26; constants.PROTOCOL_VERSION_BITS);
  offset += 2;

  obj.source = buf.toString(&#x27;hex&#x27;, offset, offset + 4);
  offset += 4;

  // Frame address
  obj.target = buf.toString(&#x27;hex&#x27;, offset, offset + 6);
  offset += 6;

  obj.reserved1 = buf.slice(offset, offset + 2);
  offset += 2;

  obj.site = buf.toString(&#x27;utf8&#x27;, offset, offset + 6);
  obj.site = obj.site.replace(/\0/g, &#x27;&#x27;);
  offset += 6;

  var frameAddressDescription = buf.readUInt8(offset);
  obj.ackRequired = (frameAddressDescription &#x26; constants.ACK_REQUIRED_BIT) !== 0;
  obj.resRequired = (frameAddressDescription &#x26; constants.RESPONSE_REQUIRED_BIT) !== 0;
  offset += 1;

  obj.sequence = buf.readUInt8(offset);
  offset += 1;

  // Protocol header
  obj.time = utils.readUInt64LE(buf, offset);
  offset += 8;

  obj.type = buf.readUInt16LE(offset);
  offset += 2;

  obj.reserved2 = buf.slice(offset, offset + 2);
  offset += 2;

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Object} parsed packet
 */
Packet.toObject = function(buf) {
var obj = {};

// Try to read header of packet
try {
  obj = this.<span class="apidocCodeKeywordSpan">headerToObject</span>(buf);
} catch (err) {
  // If this fails return with error
  return err;
}

if (obj.type !== undefined) {
  var typeName = _.result(_.find(this.typeList, {id: obj.type}), &#x27;name&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.packet.toBuffer" id="apidoc.element.node-lifx.packet.toBuffer">
        function <span class="apidocSignatureSpan">node-lifx.packet.</span>toBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBuffer = function (obj) {
  if (obj.type !== undefined) {
    // Map id to string if needed
    if (typeof obj.type === &#x27;number&#x27;) {
      obj.type = _.result(_.find(this.typeList, {id: obj.type}), &#x27;name&#x27;);
    } else if (typeof obj.type === &#x27;string&#x27; || obj.type instanceof String) {
      obj.type = _.result(_.find(this.typeList, {name: obj.type}), &#x27;name&#x27;);
    }

    if (obj.type !== undefined) {
      if (typeof packets[obj.type].toBuffer === &#x27;function&#x27;) {
        var packetTypeData = packets[obj.type].toBuffer(obj);
        return Buffer.concat([
          this.headerToBuffer(obj),
          packetTypeData
        ]);
      }
      return this.headerToBuffer(obj);
    }
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  msg.sequence = this.sequenceNumber;
  packet.sequence = this.sequenceNumber;
  if (typeof callback === &#x27;function&#x27;) {
    msg.ackRequired = true;
    this.addMessageHandler(&#x27;acknowledgement&#x27;, callback, msg.sequence);
    packet.transactionType = constants.PACKET_TRANSACTION_TYPES.REQUEST_RESPONSE;
  }
  packet.data = Packet.<span class="apidocCodeKeywordSpan">toBuffer</span>(msg);
  this.messagesQueue.unshift(packet);
  this.startSendingProcess();

  return this.sequenceNumber;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.packet.toObject" id="apidoc.element.node-lifx.packet.toObject">
        function <span class="apidocSignatureSpan">node-lifx.packet.</span>toObject
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObject = function (buf) {
  var obj = {};

  // Try to read header of packet
  try {
    obj = this.headerToObject(buf);
  } catch (err) {
    // If this fails return with error
    return err;
  }

  if (obj.type !== undefined) {
    var typeName = _.result(_.find(this.typeList, {id: obj.type}), &#x27;name&#x27;);
    if (packets[typeName] !== undefined) {
      if (typeof packets[typeName].toObject === &#x27;function&#x27;) {
        var specificObj = packets[typeName].toObject(buf.slice(constants.PACKET_HEADER_SIZE));
        obj = _.extend(obj, specificObj);
      }
    }
  }

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/* istanbul ignore if  */
if (this.debug) {
  console.log(&#x27;DEBUG - &#x27; + msg.toString(&#x27;hex&#x27;) + &#x27; from &#x27; + rinfo.address);
}

// Parse packet to object
var parsedMsg = Packet.<span class="apidocCodeKeywordSpan">toObject</span>(msg);

// Check if packet is read successfully
if (parsedMsg instanceof Error) {
  console.error(&#x27;LIFX Client invalid packet header error&#x27;);
  console.error(&#x27;Packet: &#x27;, msg.toString(&#x27;hex&#x27;));
  console.trace(parsedMsg);
} else {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-lifx.utils" id="apidoc.module.node-lifx.utils">module node-lifx.utils</a></h1>


    <h2>
        <a href="#apidoc.element.node-lifx.utils.getHardwareDetails" id="apidoc.element.node-lifx.utils.getHardwareDetails">
        function <span class="apidocSignatureSpan">node-lifx.utils.</span>getHardwareDetails
        <span class="apidocSignatureSpan">(vendorId, productId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHardwareDetails = function (vendorId, productId) {
  for (var i = 0; i &#x3c; productDetailList.length; i += 1) {
    if (productDetailList[i].vid === vendorId) {
      for (var j = 0; j &#x3c; productDetailList[i].products.length; j += 1) {
        if (productDetailList[i].products[j].pid === productId) {
          return {
            vendorName: productDetailList[i].name,
            productName: productDetailList[i].products[j].name,
            productFeatures: productDetailList[i].products[j].features
          };
        }
      }
    }
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   var versionInfo = _.pick(msg, [
     &#x27;vendorId&#x27;,
     &#x27;productId&#x27;,
     &#x27;version&#x27;
   ]);
   callback(null, _.assign(
     versionInfo,
     utils.<span class="apidocCodeKeywordSpan">getHardwareDetails</span>(versionInfo.vendorId, versionInfo.productId)
   ));
 }, sqnNumber);
};

/**
* Requests used version from the microcontroller unit of the light
* @param {Function} callback a function to accept the data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.utils.getHostIPs" id="apidoc.element.node-lifx.utils.getHostIPs">
        function <span class="apidocSignatureSpan">node-lifx.utils.</span>getHostIPs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostIPs = function () {
  var ips = [];
  var ifaces = os.networkInterfaces();
  Object.keys(ifaces).forEach(function(ifname) {
    ifaces[ifname].forEach(function(iface) {
      ips.push(iface.address);
    });
  });
  return ips;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
console.trace(err);
this.socket.close();
this.emit(&#x27;error&#x27;, err);
  }.bind(this));

  this.socket.on(&#x27;message&#x27;, function(msg, rinfo) {
// Ignore own messages and false formats
if (utils.<span class="apidocCodeKeywordSpan">getHostIPs</span>().indexOf(rinfo.address) &#x3e;= 0 || !Buffer.isBuffer(msg)) {
  return;
}

/* istanbul ignore if  */
if (this.debug) {
  console.log(&#x27;DEBUG - &#x27; + msg.toString(&#x27;hex&#x27;) + &#x27; from &#x27; + rinfo.address);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.utils.getRandomHexString" id="apidoc.element.node-lifx.utils.getRandomHexString">
        function <span class="apidocSignatureSpan">node-lifx.utils.</span>getRandomHexString
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRandomHexString = function (length) {
  var string = &#x27;&#x27;;
  var chars = &#x27;0123456789ABCDEF&#x27;;

  if (!length) {
    length = 8;
  }

  for (var i = 0; i &#x3c; length; i++) {
    var randomNumber = Math.floor(Math.random() * chars.length);
    string += chars.substring(randomNumber, randomNumber + 1);
  }

  return string;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   callback: this.processLabelPacket.bind(this)
 }];
 this.sequenceNumber = 0;
 this.lightOfflineTolerance = 3;
 this.messageHandlerTimeout = 45000; // 45 sec
 this.resendPacketDelay = 150;
 this.resendMaxTimes = 5;
 this.source = utils.<span class="apidocCodeKeywordSpan">getRandomHexString</span>(8);
 this.broadcastAddress = &#x27;255.255.255.255&#x27;;
}
util.inherits(Client, EventEmitter);

/**
* Creates a new socket and starts discovery
* @example
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.utils.isIpv4Format" id="apidoc.element.node-lifx.utils.isIpv4Format">
        function <span class="apidocSignatureSpan">node-lifx.utils.</span>isIpv4Format
        <span class="apidocSignatureSpan">(ip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isIpv4Format = function (ip) {
  var ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
  return ipv4Regex.test(ip);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof opts.resendMaxTimes !== &#x27;number&#x27;) {
  throw new TypeError(&#x27;LIFX Client resendMaxTimes option must be a number&#x27;);
}
this.resendMaxTimes = opts.resendMaxTimes;

if (typeof opts.broadcast !== &#x27;string&#x27;) {
  throw new TypeError(&#x27;LIFX Client broadcast option must be a string&#x27;);
} else if (!utils.<span class="apidocCodeKeywordSpan">isIpv4Format</span>(opts.broadcast)) {
  throw new TypeError(&#x27;LIFX Client broadcast option does only allow IPv4 address format&#x27;);
}
this.broadcastAddress = opts.broadcast;

if (!_.isArray(opts.lights)) {
  throw new TypeError(&#x27;LIFX Client lights option must be an array&#x27;);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.utils.maxNumberInArray" id="apidoc.element.node-lifx.utils.maxNumberInArray">
        function <span class="apidocSignatureSpan">node-lifx.utils.</span>maxNumberInArray
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxNumberInArray = function (array) {
  var sortedCopy = array.slice();
  sortedCopy.sort(function(a, b) {
    return a - b;
  });
  return sortedCopy[sortedCopy.length - 1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
utils.rgbToHsb = function(rgbObj) {
var red = rgbObj.r / constants.RGB_MAXIMUM_VALUE;
var green = rgbObj.g / constants.RGB_MAXIMUM_VALUE;
var blue = rgbObj.b / constants.RGB_MAXIMUM_VALUE;
var rgb = [red, green, blue];
var hsb = {};

var max = utils.<span class="apidocCodeKeywordSpan">maxNumberInArray</span>(rgb);
var min = utils.minNumberInArray(rgb);
var c = max - min;

// https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma
var hue;
if (c === 0) {
  hue = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.utils.minNumberInArray" id="apidoc.element.node-lifx.utils.minNumberInArray">
        function <span class="apidocSignatureSpan">node-lifx.utils.</span>minNumberInArray
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minNumberInArray = function (array) {
  var sortedCopy = array.slice();
  sortedCopy.sort(function(a, b) {
    return a - b;
  });
  return sortedCopy[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var red = rgbObj.r / constants.RGB_MAXIMUM_VALUE;
var green = rgbObj.g / constants.RGB_MAXIMUM_VALUE;
var blue = rgbObj.b / constants.RGB_MAXIMUM_VALUE;
var rgb = [red, green, blue];
var hsb = {};

var max = utils.maxNumberInArray(rgb);
var min = utils.<span class="apidocCodeKeywordSpan">minNumberInArray</span>(rgb);
var c = max - min;

// https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma
var hue;
if (c === 0) {
  hue = 0;
} else if (max === red) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.utils.readUInt64LE" id="apidoc.element.node-lifx.utils.readUInt64LE">
        function <span class="apidocSignatureSpan">node-lifx.utils.</span>readUInt64LE
        <span class="apidocSignatureSpan">(buffer, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt64LE = function (buffer, offset) {
  return buffer.slice(offset, offset + 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
obj.resRequired = (frameAddressDescription &#x26; constants.RESPONSE_REQUIRED_BIT) !== 0;
offset += 1;

obj.sequence = buf.readUInt8(offset);
offset += 1;

// Protocol header
obj.time = utils.<span class="apidocCodeKeywordSpan">readUInt64LE</span>(buf, offset);
offset += 8;

obj.type = buf.readUInt16LE(offset);
offset += 2;

obj.reserved2 = buf.slice(offset, offset + 2);
offset += 2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.utils.rgbHexStringToObject" id="apidoc.element.node-lifx.utils.rgbHexStringToObject">
        function <span class="apidocSignatureSpan">node-lifx.utils.</span>rgbHexStringToObject
        <span class="apidocSignatureSpan">(rgbHexString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rgbHexStringToObject = function (rgbHexString) {
  if (typeof rgbHexString !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;LIFX util rgbHexStringToObject expects first parameter to be a string&#x27;);
  }
  var hashChar = rgbHexString.substr(0, 1);
  if (hashChar !== &#x27;#&#x27;) {
    throw new RangeError(&#x27;LIFX util rgbHexStringToObject expects hex parameter with leading \&#x27;#\&#x27; sign&#x27;);
  }
  var pureHex = rgbHexString.substr(1);
  if (pureHex.length !== 6 &#x26;&#x26; pureHex.length !== 3) {
    throw new RangeError(&#x27;LIFX util rgbHexStringToObject expects hex value parameter to be 3 or 6 chars long&#x27;);
  }

  var r;
  var g;
  var b;

  if (pureHex.length === 6) {
    r = pureHex.substring(0, 2);
    g = pureHex.substring(2, 4);
    b = pureHex.substring(4, 6);
  } else if (pureHex.length === 3) {
    r = pureHex.substring(0, 1);
    r += r;
    g = pureHex.substring(1, 2);
    g += g;
    b = pureHex.substring(2, 3);
    b += b;
  }

  return {
    r: parseInt(r, 16),
    g: parseInt(g, 16),
    b: parseInt(b, 16)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   throw new RangeError(&#x27;LIFX light colorRgbHex method expects duration to be a number&#x27;);
 }

 if (callback !== undefined &#x26;&#x26; typeof callback !== &#x27;function&#x27;) {
   throw new TypeError(&#x27;LIFX light colorRgbHex method expects callback to be a function&#x27;);
 }

 var rgbObj = utils.<span class="apidocCodeKeywordSpan">rgbHexStringToObject</span>(hexString);
 var hsbObj = utils.rgbToHsb(rgbObj);
 this.color(hsbObj.h, hsbObj.s, hsbObj.b, 3500, duration, callback);
};

/**
* Sets the Maximum Infrared brightness
* @param {Number} brightness infrared brightness from 0 - 100 (in %)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.utils.rgbToHsb" id="apidoc.element.node-lifx.utils.rgbToHsb">
        function <span class="apidocSignatureSpan">node-lifx.utils.</span>rgbToHsb
        <span class="apidocSignatureSpan">(rgbObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rgbToHsb = function (rgbObj) {
  var red = rgbObj.r / constants.RGB_MAXIMUM_VALUE;
  var green = rgbObj.g / constants.RGB_MAXIMUM_VALUE;
  var blue = rgbObj.b / constants.RGB_MAXIMUM_VALUE;
  var rgb = [red, green, blue];
  var hsb = {};

  var max = utils.maxNumberInArray(rgb);
  var min = utils.minNumberInArray(rgb);
  var c = max - min;

  // https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma
  var hue;
  if (c === 0) {
    hue = 0;
  } else if (max === red) {
    hue = ((green - blue) / c);
    if (hue &#x3c; 0) {
      hue += 6;
    }
  } else if (max === green) {
    hue = 2 + ((blue - red) / c);
  } else { // max === blue
    hue = 4 + ((red - green) / c);
  }
  hsb.h = Math.round(60 * hue);

  // https://en.wikipedia.org/wiki/HSL_and_HSV#Lightness
  var lightness = max;
  hsb.b = Math.round(lightness * 100);

  // https://en.wikipedia.org/wiki/HSL_and_HSV#Saturation
  var saturation;
  if (c === 0) {
    saturation = 0;
  } else {
    saturation = (c / lightness);
  }
  hsb.s = Math.round(saturation * 100);

  return hsb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   throw new RangeError(&#x27;LIFX light colorRgb method expects duration to be a number&#x27;);
 }

 if (callback !== undefined &#x26;&#x26; typeof callback !== &#x27;function&#x27;) {
   throw new TypeError(&#x27;LIFX light colorRgb method expects callback to be a function&#x27;);
 }

 var hsbObj = utils.<span class="apidocCodeKeywordSpan">rgbToHsb</span>({r: red, g: green, b: blue});
 this.color(hsbObj.h, hsbObj.s, hsbObj.b, 3500, duration, callback);
};

/**
* Changes the color to the given rgb value
* Note RGB poorly represents the color of light, prefer setting HSBK values with the color method
* @example light.colorRgb(&#x27;#FF0000&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-lifx.utils.writeUInt64LE" id="apidoc.element.node-lifx.utils.writeUInt64LE">
        function <span class="apidocSignatureSpan">node-lifx.utils.</span>writeUInt64LE
        <span class="apidocSignatureSpan">(buffer, offset, input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt64LE = function (buffer, offset, input) {
  return input.copy(buffer, offset, 0, 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof obj.sequence === &#x27;number&#x27;) {
  buf.writeUInt8(obj.sequence, offset);
}
offset += 1;

// Protocol header
if (obj.time !== undefined) {
  utils.<span class="apidocCodeKeywordSpan">writeUInt64LE</span>(buf, offset, obj.time);
}
offset += 8;

if (typeof obj.type === &#x27;number&#x27;) {
  obj.type = _.result(_.find(this.typeList, {id: obj.type}), &#x27;id&#x27;);
} else if (typeof obj.type === &#x27;string&#x27; || obj.type instanceof String) {
  obj.type = _.result(_.find(this.typeList, {name: obj.type}), &#x27;id&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
